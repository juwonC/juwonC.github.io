---
title: "[CA]컴퓨터 명령어(1)"
excerpt: "컴퓨터 명령어"

categories:
  - CA
tags:
  - [컴퓨터 구조, 컴퓨터 명령어]

toc: true
toc_sticky: true

date: 2023-11-16
---

## 📚컴퓨터 명령어 개요
### 📄컴퓨터 명령어
* 컴퓨터가 수행해야하는 일을 나타내기 위한 비트들의 집합
* 일정한 형식을 가짐

### 📄명령어 집합
* 컴퓨터에서 사용할 수 있는 명령어의 세트
* 모든 컴퓨터는 자신의 명령어 집합을 가지고 있음
* 명령어 집합은 그 컴퓨터의 구조적인 특성을 나타내는 가장 중요한 정보
* 동일 계열의 컴퓨터는 같은 명령어 집합 사용
* 명령어 집합을 이용하여 컴퓨터 시스템의 구조를 살펴볼 수 있다

<br><br>

## 📚명령어의 구성
명령어는 0과 1의 비트들의 집합으로 필드라고 부르는 몇 개의 비트 그룹으로 나눠지며, 대표적인 필드는 연산코드 필드와 오퍼랜드 필드이다.

* 연산코드 필드: 처리해야할 연산의 종류
* 오퍼랜드 필드: 처리할 대상데이터 또는 데이터의 주소(피연산자)

![Instruction](\assets\images\CA\Instruction.png)

<br>

* 컴퓨터 명령어의 수행기능
1. 함수연산 기능: 덧셈, 시프트, 보수 등의 산술연산과 논리연산 수행 기능
2. 정보전달 기능: 레지스터들 사이에 정보전달 기능과 중앙처리장치와 주기억장치 사이의 정보 전달 기능
3. 순서제어 기능: 조건 분기과 무조건 분기 등을 통해 명령어의 수행 순서를 제어하는 기능
4. 입출력 기능: 주기억장치와 입출력장치 사이의 정보 이동 기능

<br><br>

## 📚명령어 형식
### 📄명령어 집합
명령어 집합이란 그 컴퓨터에서 사용할 수 있는 명령어의 집합을 의미한다.

모든 컴퓨터는 자신의 명령어 집합을 가지고 있고, 명령어 집합은 그 컴퓨터의 구조적인 특성을 나타내는 가장 중요한 정보이다.

컴퓨터 명령어는 컴퓨터 내부구조에 따라 여러 가지 형식이 있다.

### 📄명령어 형식의 분류
* 오퍼랜드의 기억장소에 따른 명령어 형식

1. **누산기를 이용하는 명령어 형식**: 누산기를 가진 컴퓨터 구조에서 사용되는 형식
<br>
  - 예1 ADD X; AC <- AC + M[X] 누산기(AC)에 있는 내용과 기억장치 X번지에 있는 내용을 더해서 누산기로 전송
<br>
  - 예2 LOAD X; AC <- M[X] 기억장치 X번지에 있는 내용을 누산기로 적재
<br>
  - 예3 STORE X; M[X] <- AC 누산기의 내용을 기억장치 X번지에 저장
<br><br>
2. **다중 레지스터를 이용하는 명령어 형식**: 중앙처리장치 내에 여러 개의 레지스터를 가지고 있는 컴퓨터
<br>
  - 예1 ADD R1, R2, R3; R3 <- R1 + R2 레지스터R1의 내용과 레지스터R2의 내용을 더해서 레지스터R3로전송
  - 예2 ADD R1, R2; R2 <- R1 + R2
  - 예3 MOVE R1, R2; R2 <- R1 R1의 내용을 R2로 전송
  - 예4 LOAD X, R1; R1 <- M[X] 기억장치 X번지 내용을 R1에 적재
  - 예5 STORE R1, X; M[X] <- R1 R1의 내용을 기억장치 X번지에 저장
<br><br>
3. **스택 구조를 이용하는 명령어 형식**: 연산에 필요한 오퍼랜드들을 기억장치 스택에 기억시키고 연산의 결과도 스택에 기억시키는 구조
<br>
  - 예1 ADD; TOS <- TOS + TOS<sub>-1</sub> 기억장치 스택의 맨 위(TOS)의 내용과 그 아래 내용을 더해서 스택의 맨 위로전송

<br>

* 오퍼랜드 수에 따른 명령어 형식

1. **3-주소 명령어**: 명령어 오퍼랜드 개수가 세 개인 명령어 형식
<br>
![3Address](\assets\images\CA\3Address.png)
<br><br>
X = (A + B) × C에 대해 3-주소 명령어를 이용한 프로그램
<br>
ADD A, B, R1; R1 <- M(A) + M(B)
<br>
MUL R1, C, X; M(X) <- R1 × M(C)
<br>
  - 장점: 프로그램의 길이가 짧아짐
  - 단점: 오퍼랜드를 나타내기 위한 비트 수가 많이 필요함
<br><br>
2. **2-주소 명령어**: 오퍼랜드 개수가 두 개인 명령어 형식
<br>
![2Address](\assets\images\CA\2Address.png)
<br><br>
X = (A + B) × C에 대해 2-주소 명령어를 이용한 프로그램
<br>
LOAD A, R1; R1 <- M(A)
<br>
ADD B, R1; R1 <- R1 + M(B)
<br>
MUL C, R1; R1 <- R1 × M(C)
<br>
STORE R1, X; M(X) <- R1
<br>
  - 장점: 3-주소 명령어에 비해 명령어 길이 짧아짐
  - 단점: 같은 내용 수행하기 위해 필요한 명령어 수 증가
<br><br>
3. **1-주소 명령어**: 오퍼랜드 개수가 하나인 명령어 형식. 누산기 레지스터 사용
<br>
![1Address](\assets\images\CA\1Address.png)
<br><br>
X = (A + B) × C에 대해 1-주소 명령어를 이용한 프로그램
<br>
LOAD A; AC <- M(A)
<br>
ADD B; AC <- AC + M(B)
<br>
STORE X; M(X) <- AC
<br>
LOAD C; AC <- M(C)
<br>
MUL X; AC <- AC × M(X)
<br>
STORE X; M(X) <- AC
<br>
  - 장점: 모든 연산은 누산기 레지스터와 기억장치에 저장된 오퍼랜드를 대상으로 수행
  - 단점: 같은 내용 수행하기 위해 필요한 명령어 수는 더 증가
<br><br>
4. **0-주소 명령어**: 스택 구조에서 사용되는 형식. 주소필드를 사용하지 않음
<br>
![0Address](\assets\images\CA\0Address.png)
<br><br>
X = (A + B) × C에 대해 1-주소 명령어를 이용한 프로그램
<br>
PUSH A; TOS <- M(A)
<br>
PUSH B; TOS <- M(B)
<br>
ADD; TOS <- TOS + TOS<sub>-1</sub>
<br>
PUSH C; TOS <- M(C)
<br>
MUL; TOS <- TOS × TOS<sub>-1</sub>
<br>
POP X; M(X) <- TOS
<br>
  - 장점: 명령어 길이 매우 짧아서 기억공간 적게 차지
  - 단점: 특수한 경우 제외하고 많은 양의 정보가 스택과 기억장치 사이를 이동 -> 비효율

<br><br>
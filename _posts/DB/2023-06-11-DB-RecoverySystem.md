---
title: "[DB]회복 시스템"
excerpt: "회복 시스템"

categories:
  - DB
tags:
  - [데이터베이스, 회복 시스템]

toc: true
toc_sticky: true

date: 2023-06-11
---

## 📚회복 시스템 개요
회복의 역할

1. 예상치 못한 HW 고장 및 SW 오류가 발생: 사용자의 작업에 대한 안정적 디스크 여부 보장이 불가능

2. 오류 발생 이전의 일관된 상태로 데이터베이스를 복원시키는 기법이 요구: 시스템 내의 고장 원인 검출, DBMS의 안전성 및 신뢰성을 보장

3. 데이터베이스는 데이터 복원 절차 내재화

### 📄시스템 실패의 유형

* 트랜잭션 실패
  - 논리적: 잘못된 데이터 입력, 부재, 버퍼 오버플로, 지원 초과 이용
  - 시스템적: 운영 시스템의 교착상태

* 시스템 장애
  - 시스템의 하드웨어 고장, 소프트웨어 오류
  - 주기억장치와 같은 휘발성 저장장치의 내용 손실

* 디스크 실패
  - 비휘발성 디스크 저장장치의 손상 및 고장으로 인한 데이터 손실

<br><br>

### 📄회복 데이터의 구성

* 백업: 데이터베이스의 일부 또는 전체를 다른 저장장치에 주기적으로 복제하는 방식

* 로그: 데이터베이스에서 변경 연산이 요청될 때마다 데이터 변경 이전과 이후의 값을 별도의 파일에 기록하는 방식

<br><br>

### 📄저장장치 구조와 연산

1. 데이터는 디스크와 같은 비휘발성 저장장치에 저장되고 전체 데이터의 일부만 주기억장치에 상주

2. 데이터베이스는 데이터를 블럭 단위로 전송하고 블럭 단위로 기억장소를 분할

3. 트랜잭션은 디스크로부터 주기억장치로 데이터를 가져오며, 변경된 데이터는 다시 디스크에 반영
  - 가져오기, 내보내기 연산은 블럭 단위로 실행
  - 물리적 블록: 디스크 상의 블럭
  - 버퍼 블록: 주기억장치에서 임시적으로 상주하는 블럭

DBMS는 저장장치와 메인 메모리 사이에 두 가지 연산을 수행합니다.

* Input(X): 물리적 블록(디스크상의 블럭) X를 메인 메모리에 적재
* Output(X): 버퍼 블록(메모리에 임식적으로 있는 블럭) X를 디스크에 저장

여러가지 데이터베이스 연산을 요청하는 애플리케이션은 디스크에서 메인 메모리로 정보를 읽고 다시 디스크에 정보를 쓰게됩니다.

* Read(X): 버퍼 블럭 X의 값을 변수 X에 할당합니다.
  - 버퍼 블럭 X가 메인 메모리에 없을 경우 Input(X)를 수행
  - 버퍼 블럭 X의 값을 변수 X에 할당

* Write(X): 변수 X의 값을 버퍼 블럭 X에 저장합니다.
  - 버퍼 블럭 X가 메인 메모리에 없을 경우 Input(X)를 수행
  - 변수 X의 값을 버퍼 블럭 X에 할당

<br><br><br>

## 📚로그 기반 회복
로그 기반 회복은 데이터베이스가 수행한 모든 수정 작업을 기록한 여러 종류의 로그를 사용하여 회복하는 시스템입니다.

### 📄로그 레코드 종류

* <T<sub>i</sub>, start>: T<sub>i</sub>가 시작
* <T<sub>i</sub>, abort>: T<sub>i</sub>가 취소
* <T<sub>i</sub>, commit>: T<sub>i</sub>가 커밋
* <T<sub>i</sub>, X<sub>j</sub>, V<sub>1</sub>, V<sub>2</sub>>: T<sub>i</sub>가 데이터 항목 변경 연산을 수행하여 X<sub>j</sub>의 값을 V<sub>1</sub>에서 V<sub>2</sub>로 변경

<br><br>

### 📄데이터 항목 변경 과정

* WAL(Write-Ahead Log)
  - 트랜잭션은 데이터베이스 수정 전, 로그 레코드를 생성하여 기록

* 데이터 항목을 변경하는 과정
  - 트랜잭션은 메인 메모리의 개인 영역에서 여러 연산을 수행
  - 트랜잭션은 데이터 항목이 존재하는 메인 메모리에 위치한 버퍼 블럭의 데이터를 변경
  - Output 명령을 실행하여 버퍼 블럭을 디스크에 기록

<br>

회복을 위해 로그를 사용하여 수행할 수 있는 연산은 다음과 같습니다.

* Redo(T<sub>i</sub>): T<sub>i</sub>에 의하여 수정된 새로운 값으로 데이터베이스의 데이터 항목값을 수정
* Undo(T<sub>i</sub>): T<sub>i</sub>에 의해 수정된 모든 데이터 항목을 이전 값으로 복귀, 완료 후 <T<sub>i</sub>, abort> 기록

* 시스템 장애 발생 시
  - 로그에 <T<sub>i</sub>, start>가 있지만 <T<sub>i</sub>, commit> 또는 <T<sub>i</sub>, abort> 를 포함하지 않는 경우 T<sub>i</sub>는 Undo

  - 로그에 <T<sub>i</sub>, start>가 있지만 <T<sub>i</sub>, commit> 또는 <T<sub>i</sub>, abort> 를 포함하는 경우 T<sub>i</sub>는 Redo


* 데이터베이스 변경 시 복구 알고리즘의 고려사항
  - 트랜잭션의 일부 변경 사항이 버퍼 블록에만 반영되고 물리 블록에 기록되지 않은 상태에서 트랜잭션이 커밋되는 상황
  - 트랜잭션이 동작 상태에서 데이터베이스를 수정했으나 수정 후에 발생한 실패로 취소가 필요한 상황

* 트랜잭션 커밋 상황
  - <T<sub>i</sub>, commit> 로그 레코드가 안정된 저장장치에 기록 완료 시 트랜잭션 커밋으로 간주
  - <T<sub>i</sub>, commit> 로그 레코드가 기록되기 전에 장애가 발생하는 롤백

<br><br>

### 📄회복의 유형
회복은 트랜잭션에 의해 요청된 갱신 작업이 디스크에 반영되는 시점에 따라 구분됩니다.

* 지연 갱신 회복
  - 부분 커밋까지 디스크 반영을 지연시키고 로그에만 기록
  - 실패 시, 별도의 회복 작업 필요 없이 로그만 수정

* 즉시 갱신 회복
  - 갱신 요청을 곧바로 디스크에 반영
  - 실패 시, 디스크에 반영된 갱신 내용을 로그를 바탕으로 회복

<br><br>

### 📄체크포인트를 이용한 회복
* 로그 기반 회복 시스템의 한계
  - 로그의 크기는 시간이 지남에 따라 계속 증가하므로 대용량 로그의 탐색 비용이 매우 커짐
  - Redo를 해야 하는 트랜잭션 중 대부분은 이미 데이터베이스에 반영
  - 반영된 트랜잭션의 재실행은 시스템 자원의 낭비

이런 문제점을 해결하기 위해 회복 작업에 소모되는 비용을 감소시킬 수 있는 체크포인트 기법을 사용합니다.

체크포인트 시점에 수행되는 작업은 다음과 같습니다.

* 현재 시점에 메인 메모리의 버퍼 블럭에 존재하는 모든 로그 레코드를 안정 저장장치로 기록
* 수정된 모든 버퍼 블럭을 디스크에 반영
* 로그 레코드 <checkpoint ListT>를 안전한 저장장치에 기록(ListT는 체크 포인트 시점에 실행 중인 트랜잭션 목록입니다.)


* 체크포인트 기법일 이용한 회복과정
  - 로그의 마지막부터 역방향을 탐색하여 <checkpoint ListT> 레코드를 찾음
  - ListT에 존재하는 <checkpoint ListT> 이후에 실행된 트랜잭션에 대하여 Redo와 Undo 연산만 수행
    + 로그에 <T<sub>i</sub>, commit> 또는 <T<sub>i</sub>, abort>가 없는 ListT안의 모든 트랜잭션을 Undo
    + 로그에 <T<sub>i</sub>, commit> 또는 <T<sub>i</sub>, abort>가 있는 ListT안의 모든 트랜잭션을 Redo

<br><br><br>

## 📚회복 알고리즘
### 📄트랜잭션 롤백 알고리즘

1. 로그를 역방향으로 탐색
2. T<sub>i</sub>의 로그 레코드 <T<sub>i</sub>, X<sub>j</sub>, V<sub>1</sub>, V<sub>2</sub>>에 대해
  - 데이터 항목 X<sub>j</sub>에 V<sub>1</sub>을 기록
  - 로그 레코드 <T<sub>i</sub>, X<sub>j</sub>, V<sub>1</sub>>을 로그로 기록
3. <T<sub>i</sub>, start>를 찾은 이후
  - 역방향 탐색 중단
  - 로그 레코드 <T<sub>i</sub>, abort>를 로그에 기록

<br><br>

### 📄시스템 장애 후 회복 알고리즘
시스템 장애 이후 재시작 시 두 단계를 거칩니다.

1. Redo단계
  - 최근의 체크포인트에서부터 순방향 로그 탐색
  - 롤백 대상할 트랜잭션의 Undo 리스트인 ListofUndo를 ListT로 초기화
  - <T<sub>i</sub>, X<sub>j</sub>, V<sub>1</sub>, V<sub>2</sub>>, <T<sub>i</sub>, X<sub>j</sub>, V<sub>1</sub>> 형태의 모든 레코드를 재실행
  - <T<sub>i</sub>, start> 발견 시, T<sub>i</sub>를 ListofUndo에 추가
  - <T<sub>i</sub>, abort>, <T<sub>i</sub>, commit> 발견 시 T<sub>i</sub>를 Undo 리스트에서 제거

2. Undo 단계(역방향 로그 탐색)
  - ListofUndo의 트랜잭션의 로그레코드를 찾으면 트랜잭션 롤백 알고리즘 1단계 수행
  - ListofUndo의 트랜잭션 T<sub>i</sub>에 대해 <T<sub>i</sub>, start>를 만나면 로그에 <T<sub>i</sub>, abort>를 기록하고 ListofUndo에서 제거
  - ListofUndo에 트랜잭션이 존재하지 않는 상태가 되면 Undo 단계를 종료

<br><br><br>

## 📚백업
DBMS는 데이터베이스를 시스템 장애로부터 보호하기 위해 백업과 복원 기능을 지원합니다.

* 백업: 결함으로 발생 가능한 데이터 손실로부터 대비하는 수단입니다. 데이터 베이스의 원본을 복제하여 물리적으로 분리된 시스템 또는 저장장치에 복제해 놓는 것을 말합니다.

* 복원: 문제발생 시 복제된 데이터를 사용하여 문제 발생 시점 이전으로 되돌리는 작업을 의미합니다.

<br><br>
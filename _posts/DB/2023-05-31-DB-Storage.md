---
title: "[DB]데이터 저장과 파일"
excerpt: "데이터 저장과 파일"

categories:
  - DB
tags:
  - [데이터베이스, 데이터 저장과 파일]

toc: true
toc_sticky: true

date: 2023-05-31
---

## 📚물리적 저장장치 구조
물리적 저장장치는 데이터 접근 속도, 용량을 기준으로 다양한 장치로 구성됩니다. 컴퓨터는 물리적 다양한 저장장치를 계층적으로 구성합니다. 상위에 위치한 저장장치일수록 고가이지만 데이터 접근 소요 시간이 짧습니다. 반면에 하위에 위치한 저장장치일수록 저가이지만 데이터 접근 소요 시간이 증가합니다.

![MemoryHierarchy](\assets\images\DB\MemoryHierarchy.png)
<br>
[https://en.wikipedia.org/wiki/Memory_hierarchy](https://en.wikipedia.org/wiki/Memory_hierarchy)

<br>

* 물리적 저장장치별 특징

1. 휘발성
  - 캐시: 고비용 저장장치로 빠른 접근 속도를 보장
  - 메인 메모리: 실제 프로그램과 데이터 적재 공간
<br><br>
2. 비휘발성
  - 플래쉬 메모리: 메인 메모리와 유사하나 비휘발성
  - 자기 디스크: 데이터베이스 전체를 안정적으로 저장
  - 광학 디스크: CD, Blue-ray 등
  - 테이프 장치: 용량이 크고 저렴하지만 순차 접근 방식으로 인해 접근 속도가 매우 느림

<br><br><br>

## 📚파일의 구성
DBMS는 데이터를 저장하기 위해 파일 시스템을 이용하고 이 시스템을 통해 저장장치에 접근하고 파일에 저장된 데이터를 사용합니다.

**파일**은 데이터를 영구적으로 저장하기 위해 사용하는 컴퓨터 시스템의 가장 기초적인 구조입니다. 파일은 **블럭** 단위로 분할되어 기록됩니다. 블럭은 파일을 고정적 길이로 분할하여 생기는 균등한 크기의 데이터 묶음을 의미합니다. 또한 블럭은 일반적으로 메모리와 디스크간의 데이터 전송 단위로 결정됩니다.

하나의 블럭은 다시 여러 개의 레코드로 구성됩니다. 상황에 따라 하나의 레코드가 블럭의 크기보다 큰 경우 여러 블럭에 나뉘어 저장되는 경우도 있습니다. **레코드**는 블럭을 구성하는 요소로 더 이상 분리될 수 없는 최소 데이터 저장 단위입니다.

<br><br>

### 📄고정 길이 레코드
고정 길이 레코드는 각 레코드에 고정적인 바이트 수를 할당하는 방법입니다.

![FixLength](\assets\images\DB\FixLength.png){: width="400" height="400"}

* 데이터 접근
  - 모든 레코드는 42 바이트 크기로 구성
  - i번째 레코드 접근: (i - 1) * 42 + 1번째 바이트부터 42개의 바이트를 읽어 접근

<br>

* 잔여 고정 길이 레코드 할당
<br>
블럭의 길이가 레코드 길이로 정확히 나눠지지 않아 잔여 공간을 비워두는 방법입니다. 이 방법은 간편하고 빠르게 저장 가능하다는 장점이 있지만 블럭 내의 남은 공간이 낭비된다는 단점이 있습니다.

![FixLengthAlloc](\assets\images\DB\FixLengthAlloc.png){: width="400" height="400"}

<br>

* 고정 길이 레코드 할당
<br>
블럭의 길이가 레코드 길이로 정확히 나눠지지 않아 한 레코드를 두 블럭에 나누어 저장하는 방법입니다. 레코드 접근 시 두 블럭에 접근해야 합니다. 이 방법은 저장 공간이 낭비되지 않는다는 장점이 있지만 하나의 레코드를 읽으려고 할 때 디스크에서 두 개의 블럭에 접근해야해서 시간이 오래 걸린다는 단점이 있습니다.

<br>

* 고정 길이 레코드 할당의 문제

1. 레코드 삭제 시
  - 해당 레코드가 저장된 위치에 빈공간이 생성
  - 장시간 레코드의 삽입 및 삭제 발생 시, 저장 공간에 많은 낭비가 발생
<br><br>
2. 레코드 삭제 시 대처 방안
  - 마지막 레코드로 공백 대체: 레코드 순서가 바뀌는 문제 -> 검색 시간 길어질 수 있음
  - 삭제 레코드 이후의 레코드를 이동: 첫번째 레코드가 빠지면 나머지 전체 레코드를 다 이동해야해서 시간이 오래 걸림. 오버헤드가 크다
  - 가용 리스트 관리: 파일 헤더에 가용 리스트 정보(공백 레코드 포인터)를 위치시킨다.

<br><br>

### 📄가변 길이 레코드
가변 길이 레코드 방식은 블럭에 저장되는 레코드의 길이가 서로 다른 레코드를 할당하는 방법입니다.

* 가변 길이 레코드가 사용되는 상황

  - 한 블럭 내에 저장되는 레코드 유형이 둘 이상
  - 길이가 고정되지 않은 컬럼의 개수가 하나 이상
  - 레코드가 멀티셋을 허용한 컬럼을 가질 때

멀티셋: 레코드의 컬럼값이 여러 개인 컬럼

![VarLength](\assets\images\DB\VarLength.png){: width="400" height="400"}

<br>

* 슬롯페이지 구조
가변 길이 레코드를 위해 사용되는 대표적인 구조입니다.

![SlottedPage](\assets\images\DB\SlottedPage.png){: width="400" height="400"}

<br><br>

### 📄파일 구조
파일 구조화는 파일 수준에서 레코드를 관리하는 기법입니다. 파일 구조화 방법에는 세 가지 유형이 있습니다.

* **힙 파일 구조**
<br>
힙 파일 구조는 저장 순서 고려없이 파일 내 임의의 위치에 배치하는 방식입니다. 이 방식은 저장 속도가 빠르지만 검색이 느립니다.

<br>

* **순차 파일 구조**
<br>
레코드들이 탐색키 기준으로 정렬되어 저장되는 방식입니다. 레코드가 검색키 순서대로 정렬하여 생성되는 파일을 키 순차 파일이라고 합니다. 레코드가 파일에 삽입되는 시점에 키 값이 부여됩니다. 순차 파일 방식은 아래와 같은 장단점이 있습니다.
<br><br>
  - 순차 파일 방식 장점
    <br>
    + 검색키에 대한 정렬 연산이 불필요, 키 값들의 순서로 레코드를 판독하는 연산이 매우 효율적
    + 현재 레코드에서 정렬된 키 순서로 다음 레코드를 찾을 때 부가적인 블럭 접근을 필요로 하지 않음
    + 이진 탐색을 사용하면 더 빠르게 레코드를 검색 가능
  <br><br>
  - 순차 파일 방식 단점
    <br>
    + 레코드 삽입, 삭제에 많은 비용 소요
    + 탐색키가 아닌 컬럼의 값을 이용하여 탐색하는 것이 비효율적임

💡순차 파일 구조의 저장 방식을 개선하기 위해 오버플로 블럭을 사용합니다. 오버플로 블럭은 순차 파일 구조에서 레코드의 정렬된 상태를 유지하기 위해 삽입된 신규 블럭입니다.

<br>

* **해시 파일 구조**
<br>
해시 함수를 사용하여 블럭 주소를 계산하는 방식입니다. 해시 함수는 레코드 탐색키를 입력받아 레코드가 저장될 블럭 주소를 반환하고 해당 주소에 레코드를 저장합니다.

<br><br><br>

## 📚저장장치 접근
파일은 논리적 관점에서의 저장 단위이기 때문에 실제 저장될 때 여러 개의 물리적 단위인 블럭으로 저장됩니다. 블럭은 메모리와 디스크 간 데이터의 전송 단위이고 일반적으로 2KB ~ 32KB 사용합니다. 블럭 전송 횟수를 최소화 할 수록 입출력 소요 시간이 단축됩니다.

* 블럭 전송 횟수 최소화 방법

  - 사용 중인 블럭을 지속적으로 메모리에 적재
  - 한정적 공간으로 인하여 필요에 따라 특정 블럭 할당을 해지
  - 메모리 내부에 **버퍼**라는 공간에 블럭을 저장하고, 이를 관리하기 위한 **버퍼 관리자** 사용

<br>

* **버퍼 관리자**
<br>
DBMS상의 소프트웨어는 필요한 블럭이 있을 때 버퍼 관리자에게 해당 블럭을 요청합니다.

  - 요청된 블럭이 버퍼에 있다면 버퍼 관리자는 블럭이 위치한 메모리 주소를 프로그램에 전달합니다.
  - 요청된 블럭이 없는 경우, 버퍼 관리자는 버퍼 내의 새로운 공간을 할당하고 해당 블럭을 적재합니다.
  - 더 이상 적재할 공간이 없다면 버퍼에 있는 기존 블럭을 선택하여 할당을 해지하고 해당 블럭을 적재합니다.

<br>

* **버퍼 교체 전략(buffer replacement strategy)**
<br>
어떤 메모리의 블럭을 디스크로 내보내야할지 결정하는 알고리즘입니다. 가용 공간을 확보하기 위해 기존에 적재된 블럭의 할당을 특정 기준에 의하여 해지합니다. 미래에 가장 적게 사용될 블럭을 선택하여 디스크로 내보내는 것이 가장 이상적인 버퍼 교체 전략입니다.
<br><br>
  - LRU(Least Recently Used): 최근에 가장 적게 참조된 블럭을 교체
  - MFU(Most Frequently Used): 특정 기간동안 가장 여러번 사용된 블럭을 선택하여 교체

<br>

* **고정 블럭(pinned blocks)**
<br>
하드웨어 또는 소프트웨어 결함으로 데이터가 손실되어 작업이 중단될 경우 중단된 작업의 중간 결과물이 디스크에 기록되는 것을 방지해야 합니다. 이를 위해 디스크 블럭이 교체되는 것을 임시적으로 제한해야 합니다. 블럭이 교체되는 것을 제한하기 위해 특정 블럭을 고정시키는데 이를 고정 블럭이라고 합니다.

<br>

* **블럭 강제 출력(forced output of blocks)**
<br>
중요한 데이터는 디스크에 영구적으로 기록되어야 하기 때문에 선택되지 않아도 강제적으로 디스크로 내보내야 합니다. 중요 블럭은 버퍼 공간이 부족하지 않은 상태임에도 불구하고 필요에 따라 강제로 디스크에 기록되는데 이를 블럭 강제 출력이라고 합니다.

<br><br>
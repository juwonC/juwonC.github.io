---
title: "[DB]관계형 모델(2)"
excerpt: "논리적 데이터 모델링"

categories:
  - DB
tags:
  - [데이터베이스, 관계형 모델]

toc: true
toc_sticky: true

date: 2023-03-13
---

## 📚논리적 데이터 모델링
ER 모델은 개념적 데이터 모델이라 DBMS에 바로 적용할 수 없습니다. 따라서 개념적 모델을 DBMS에 맞는 논리적 데이터 모델로 변환하는 작업이 필요합니다.

### 📄ER 다이어그램의 관계형 모델 변환
ER 다이어그램(ERD)에 포함된 개제 집합과 관계 집합 등을 관계형 모델의 릴레이션으로 변환하는 작업이 필요합니다. ER 모델의 속성은 릴레이션의 컬럼, 개체 집합은 릴레이션, 개체는 레코드에 각각 대응됩니다.

<br>

ERD의 모든 표현은 훼손 없이 관계형 모델의 스키마로 변환되어야 합니다.
  1. 개체 집합: 개체 집합은 릴레이션으로 변환되고 키 속성 중 하나를 기본키로 지정합니다.
  2. 약한 개체 집합: 혼자 존재할 수 없는 개체 집합이라 지배 개체인 강한 개체 집합의 키 속성을 포함 시킵니다. 강한 개체는 독자적으로 존재할 수 있는 개체입니다.
  3. 일대일 관계: 일대일의 연결되는 이항 관계는 관계 집합에 참여하는 두 릴레이션 중 어느 하나를 다른 릴레이션의 기본키를 참조하는 외래키 컬럼으로 변환합니다.
  4. 일대다 혹은 다대일 관계: 다 쪽 릴레이션의 외래키 컬럼으로 변환하고, 일 쪽의 기본키를 참조하도록 외래키를 지정합니다.
  5. 다대다 관계: 관계 릴레이션을 별도로 생성하고 관계에 참여하는 릴레이션의 기본키를 각각 참조하는 외래키로 복합키 형태의 컬럼을 구성합니다.
  6. 다중값 속성: 기본키와 다중값 속성을 별도의 릴레이션으로 구성하고 새로운 릴레이션의 기본키로 지정합니다.
  7. 관계 집합의 속성: 각각의 속성을 외래키가 위치한 릴레이션의 컬럼으로 삽입합니다.
  8. n항 관계: 관계에 참여하는 n개의 릴레이션의 키들로 구성되는 관계 릴레이션으로 변환합니다. 관계 릴레이션의 컬럼들은 참여 릴레이션의 기본키를 참조하는 외래키와 관계 컬럼으로 구성합니다.

<br><br><br>

## 📚데이터 조작
데이터 모델은 데이터의 구조와 제약, 데이터 조작을 위한 연산의 정의를 포함하고 있습니다. 관계형 모델은 스키마로부터 특정 데이터를 추출하는 데이터 연산 방법을 관계 대수를 통해 제공합니다.

### 📄관계 대수의 이해
SQL은 질의에 필요한 데이터와 데이터에 대한 조건만 기술하는 선언적 언어인 반면 관계 대수는 질의 처리 과정을 단계적으로 표현하는 절차적 언어입니다. DBMS는 관계 대수를 실행 엔진의 내부 언어로 사용합니다.

### 📄기본연산자
* 셀렉트
<br>
셀렉트(select) 연산자는 릴레이션에서 조건을 만족하는 레코드들을 선택합니다. 검색 조건에 =, ≠, >, ≥, <, ≤ 관계 연산자를 사용할 수 있습니다. 또한 두 개 이상의 조건은 논리 연산자 AND(∧), OR(∨), NOT(¬)을 이용하여 결합할 수 있습니다.

$$ \sigma_{조건}(입력 \; 릴레이션) $$

<br>

* 프로젝트
<br>
프로젝트(project) 연산자는 입력된 릴레이션의 특정 컬럼만 추출하여 새로운 릴레이션으로 재구성합니다. 결과에 포함시킬 컬럼을 파이 뒤에 아래첨자로 나열하고 입력 릴레이션은 소괄호 내부에 위치시킵니다.

$$ \Pi_{A_{1}, A_{2}, ..., A_{n}}(입력 \; 릴레이션) $$

<br>

* 집합 연산자
<br>
집합 연산자는 호환 가능한 릴레이션 사이에만 사용할 수 있습니다. 릴레이션 R과 S에서 집합 연산자를 사용하기 위한 조건은 아래와 같습니다.
<br><br>
1. 릴레이션 R과 S가 가지고 있는 컬럼 수가 같아야 한다.
2. 모든 i에 대해 릴레이션 R의 i번째 컬럼의 도메인과 릴레이션 S의 i번째 컬럼의 도메인이 같아야 한다.
<br><br>
  - 합집합
  <br>
  합집합 연산은 두 릴레이션의 모든 레코드를 포함한 릴레이션이 결과가 됩니다. 합집합 연산자는 기호 ∪로 나타냅니다.
  <br>
  합집한 연산의 결과에서 양쪽 릴레이션에 존재하는 중복된 레코드는 한 번만 표현합니다.(레코드의 유일성)
  <br><br>
  - 차집합
  <br>
  차집합 연산자는 기호 -로 나타냅니다. 차집합 연산은 한 릴레이션에는 포함되지만 다른 릴레이션에는 포함되지 않는 레코드를 가지는 릴레이션을 반환하는 연산자입니다.
  <br><br>
  - 교집합
  <br>
  교집합 연산자는 기호 ∩로 나타냅니다. 교집합 연산은 양쪽 릴레이션 동시에 포함되는 리코드의 집합을 생성합니다.

<br>

* 리네임 연산자
<br>
리네임(Rename) 연산은 관계 대수식에 새로운 이름을 부여하는 연산자입니다. 관계 대수의 결과로 생성된 릴레이션은 이름을 가지고 있지 않기 때문에 이를 재사용하기 위해 참조할 목적으로 리네임 연산자를 사용하여 이름을 부여합니다.

$$ \rho_{부여할 \; 이름}(입력 \; 릴레이션) $$

<br>

* 카티션 프로덕트
<br>
카티션 프로덕트(Cartesian Product)는 서로 다른 릴레이션 간의 관계성을 이용하는 연산자로서 앞서 살펴본 연산자들에 비해 좀 더 복잡합니다. 카티션 프로덕트 연산은 두 릴레이션 레코드 간에 모든 조합을 취하여 결합한 레코드를 생산합니다. 또한 기호 ✕로 표시합니다.

$$ R \times S = \{(rs)|r \in R \wedge s \in S\} $$

<br>

* 조인
<br>
조인(join) 연산은 두 릴레이션으로부터 서로 관련된 레코드만 결합하여 결과에 포함시킵니다. 조인 연산은 특정 조건을 만족하는 레코드 조합만 결과에 포함시킨다는 점에서 카티션 프로덕트와 다릅니다. 조인 연산 중 하나인 세타 조인은 관계연산자 $$ \theta $$로 정의되는 조인조건을 가집니다. $$ \theta $$는 =, ≠, >, ≥, <, ≤ 관계 연산자 중 하나가 되는데 '='인 경우 동등 조인이라고 합니다.

$$ R⋈_{A\theta B}S =   \sigma_{A \theta B}(R \times S) $$

<br><br><br>

### 📄확장 연산자
기본 연산자만 사용한 관계 대수식으로 질의를 표현할 경우 표현식이 복잡해져 가독성이 떨어지는 단점 있습니다. 하지만 확장 연산자를 사용하면 이런 문제를 해결할 수 있습니다.

<br>

* 자연 조인 연산자
<br>
자연 조인은 동등 조인을 간결할게 표현할 수 있는 연산자입니다. R⋈<sub>n</sub>S에 대해 3단계 연산 과정이 이뤄집니다.
<br><br>
1. R과 S에 대한 카티션 프로덕트 생성
2. R과 S에 동일한 이름의 컬럼 값이 같은 레코드만 선택
3. 중복되는 컬럼을 한 번만 표현한 결과를 반환

<br><br>

* 할당 연산자
<br>
할당 연산자는 관계 대수식의 결과를 임시적으로 릴레이션 변수에 저장시키는 연산자입니다. 할당 연산자는 기호 ←로 나타냅니다. 특정 릴레이션 변수로 할당된 중간 생성물은 다른 관계 대수식에서 하나의 릴레이션처럼 사용될 수 있습니다.

$$ temp1 \leftarrow 학생 ⋈ 계좌 $$

<br><br>

* 집계 함수 연산
<br>
특정 릴레이션에 대해 여러 통계학 수치를 필요로할 때가 있습니다. 이를 위해 $$ \mathcal{G} $$(caligraph G)로 표기되는 집계 함수를 사용합니다. 집계 함수는 집계를 통하여 얻은 수치를 릴레이션에 포함시킵니다.

  | 집계 함수 | 역할 |
  | :---: | :---: |
  | sum | 값의 총합을 반환 |
  | avg | 값의 평균값을 반환 |
  | count | 집합을 구성하는 원소들의 개수를 반환 |
  | max | 집합 내 가장 큰 값을 반환 |
  | min | 집합 내 가장 작은 값을 반환 |
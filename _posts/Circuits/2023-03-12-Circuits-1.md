---
title: "[Circuits]수치 데이터"
excerpt: "수치 데이터"

categories:
  - Circuits
tags:
  - [디지털 논리회로, 진법, 보수]

toc: true
toc_sticky: true

date: 2023-03-12
---

## 📚진법
### 📄수와 숫자
수는 숫자라는 기호로 나타냅니다.
<br>
수는 하나의 개념이고 숫자는 사람들이 의사소통을 위해 정한 기호인 것 입니다.

<br>

### 📄진법
진법은 숫자의 위치에 따라 가중치를 부여하는 방법입니다.
<br>
가중치는 기수의 승수를 이용합니다. 기수는 2 이상의 양의 정수이고 기수가 r인 경우 r진법이라고 합니다. r진법은 r개의 숫자로 수를 표현하고 이렇게 표현된 수를 r진수라고 합니다.
<br>
예를 들면, 10진법은 10개의 숫자(0 ~ 9)로 수를 표현하고 2진법은 2개의 숫자 0, 1로 수를 표현합니다.
<br>

12.1<sub>10</sub> = 1 X 10<sup>1</sup> + 2 X 10<sup>0</sup> + 1 X 10<sup>-1</sup>
<br>
101.01<sub>2</sub> = 1 X 2<sup>2</sup> + 0 X 2<sup>1</sup> + 1 X 2<sup>0</sup> + 0 X 2<sup>-1</sup> + 1 X 2<sup>-2</sup>

<br>

### 📄진수변환
1. r진수의 10진수 변환
<br>
다음 식들을 보면 간단하게 r진수를 10진수로 변환할 수 있을 것 입니다.
<br><br>
11.01<sub>2</sub> = 1 X 2<sup>1</sup> + 1 X 2<sup>0</sup> + 0 X 2<sup>-1</sup> + 1 X 2<sup>-2</sup>
<br>
　　　 = 2 + 1 + 0 + 0.25
<br>
　　　 = 3.25
<br><br>
1A.2<sub>16</sub> = 1 X 16<sup>1</sup> + 10 X 16<sup>0</sup> + 2 X 16<sup>-1</sup>
<br>
　　　 = 16 + 10 + 0.125
<br>
　　　 = 26.125
<br><br>

2. 10진수의 r진수 변환
<br>
10진수 123.125를 2진수로 변환하면 정수부분 123이 몫이 0이 될때까지 2로 계속 나눠주면 됩니다. 소수부분 변환은 0.125가 0이 될때까지 2를 계속 곱해주면 됩니다. r진수 변환은 앞에서 예를 들었던 2대신 r로 계속 나누거나 곱해주면 됩니다.
<br><br>
　　정수부분 변환　　　　　　　　소수부분 변환
<br>
![decToBin](/assets/images/decToBin.png){: width="200" height="200"}　　　
![decFractionToBin](/assets/images/decFractionToBin.png){: width="200" height="200"}
<br><br>
123.125<sub>10</sub> = 11011.001<sub>2</sub>이 됩니다.
<br><br>
간혹 10진수 0.3 같이 2진수로 변환할 때 소수부분이 0이 되지 않고 2를 곱할 때 무한히 계산되는 경우가 있습니다. 이런 경우 필요한 만큼 잘라서 사용하면 됩니다.
<br><br>

3. 2진수와 2<sup>n</sup>진수의 상호 변환
<br>
2진수를 구성하는 각 자릿수는 비트라고 합니다. 2개의 비트는 00, 01, 10, 11을 표현할 수 있고 이는 모두 4(2<sup>2</sup>)개입니다. 일반적으로 n개의 비트로는 2<sup>n</sup>개의 수를 표현할 수 있습니다.
<br>
2진수를 4진수, 8진수, 16진수 등으로 변환하고 그 역의 변환 방법에 대해 알아봅시다.
<br><br>
2진수의 비트를 소수점을 중심으로 2개씩 묶으면 00, 01, 10, 11 조합을 얻을 수 있습니다. 이는 각각 한 자리의 4진수 0, 1, 2, 3에 대응됩니다. 8진수는 2진수를 3비트씩 묶으면 되고 16진수는 2진수를 4비트씩 묶어서 변환할 수 있습니다.
<br>
![binTohex](/assets/images/binaryTo.png){: width="600" height="600"}
<br>
2진수 비트들을 n비트씩 묶을 때 부족한 비트 수만큼 0이 있다고 가정해야합니다.
<br>
2<sup>n</sup>진수를 2진수로 변환할 때는 2<sup>n</sup>의 각 자리 수에 대응하는 n비트의 2진수로 모두 바꾸면 됩니다. 예를 들어 16진수 2D.6<sub>16</sub>을 2진수로 변환하면 2, D, 6을 2진수로 각각 변화하면 됩니다.
<br><br>

4. 기타변환
<br>
r진수를 s진수로 변환하는 경우 먼저 r진수를 10진수로 바꾼 다음 10진수를 s진수로 변환합니다.
<br>
예를 들어 5진수를 8진수로 변환한다고 했을 때 5진수를 10진수로 변환하고 바꾼 10진수를 8진수로 변환하면 됩니다.

<br><br>

### 📄산술연산
r진수에 대한 산술연산은 10진수의 산술연산과 같습니다. r진수는 r개의 숫자만 사용할 수 있다는 것만 다릅니다.
<br>
* 2진수 가산(덧셈)
<br>
101<sub>2</sub> + 100<sub>2</sub> = 1001<sub>2</sub>

* 2진수 제산(뺄셈)
<br>
1101<sub>2</sub> - 111<sub>2</sub> = 110<sub>2</sub>

* 2진수 승산(곱셈)
<br>
110<sub>2</sub> * 11<sub>2</sub> = 10010<sub>2</sub>

* 2진수 제산(나눗셈)
<br>
2진수의 나눗셈은 나누어지는 수(피제수)에서 나누는 수(제수)를 계속 빼서 나누어지는 수가 나누는 수보다 최초로 작아지거나 0이 될 때, 그때까지 뺀 횟수가 몫이 되고 빼고 남은 값이 나머지가 됩니다.
<br><br>
110101<sub>2</sub> / 110<sub>2</sub> = 1000<sub>2</sub>, 나머지 101<sub>2</sub>


<br>

2진수가 아닌 r진수들의 산술연산은 10진수로 변환하여 연산을 진행해주는 것이 편합니다.

<br><br><br>

## 📚보수
보수를 이용하여 컴퓨터에서의 감산이 가산만으로도 가능하다는 것을 설명할 수 있습니다. r진수 N은 r의 보수와 r-1의 보수 두가지 보수가 있습니다.
### 📄보수의 개념
* r의 보수
<br>

$$ N에\;대한\;r의\;보수 = \begin{cases}r^n-N,&N ≠ 0 \\ 0,&N = 0 \end{cases}$$

<br>

* r-1의 보수
<br>

정수부분이 n개의 자리로 구성되고 소수점 아래가 m개의 자리로 구성된 r진수 N에 대한 r-1의 보수에 대한 식입니다.
<br>

$$ N에\;대한\;(r-1)의\;보수 = r^n - r^m - N $$

<br>
r의 보수와 r-1의 보수의 관계는 아래와 같습니다.

$$ r의\;보수 = (r-1)의\;보수 + 가장\;낮은\;자리의\;1 $$

<br><br>

### 📄보수를 이용한 감산
감수를 부호를 포함하여 r의 보수를 한 다음 피감수에 가산합니다.

$$ \pm A - (\pm B) = \pm A + (\mp B) $$

<br><br><br>

## 📚부호 있는 2진수
### 📄부호 있는 절대치 표현
부호 있는 절대치 표현방법은 수의 크기와 부호를 나타내는 비트로 구성하여 표현합니다.
<br>

실생활에서 우리는 음수 양수를 구분하기 위해 숫자 앞에 부호를 씁니다. 비트로도 음의 정수를 표현하기 위해 부호와 같은 역할을 하는 비트를 정했습니다. 가장 왼쪽에 위치한 비트(MSB)를 부호로 약속하고 이 부호 비트가 1이면 음수로 0이면 양수로 표현합니다. 예를 들어 4비트 크기의 값이 있을 때 MSB를 부호 비트로 정하고 나머지 3비트를 사용하여 수를 표현할 수 있습니다. 따라서 -7부터 7까지 표현할 수 있습니다. 쉽게 말하면 가장 왼쪽의 비트가 부호를 결정하는 비트가 되는 것 입니다.
<br>

　　　　양수　　　　　　　　　음수
<br>

| 부호 | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> | 십진수 |   | 부호 | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> | 십진수 |
| :---: | :---: | :---: | :---: | :---: |   | :---: | :---: | :---: | :---: | :---: |
| 0 | 1 | 1 | 1 | +7 |   | 1 | 0 | 0 | 0 | -0 |
| 0 | 1 | 1 | 0 | +6 |   | 1 | 0 | 0 | 1 | -1 |
| 0 | 1 | 0 | 1 | +5 |   | 1 | 0 | 1 | 0 | -2 |
| 0 | 1 | 0 | 0 | +4 |   | 1 | 0 | 1 | 1 | -3 |
| 0 | 0 | 1 | 1 | +3 |   | 1 | 1 | 0 | 0 | -4 |
| 0 | 0 | 1 | 0 | +2 |   | 1 | 1 | 0 | 1 | -5 |
| 0 | 0 | 0 | 1 | +1 |   | 1 | 1 | 1 | 0 | -6 |
| 0 | 0 | 0 | 0 | +0 |   | 1 | 1 | 1 | 1 | -7 |

<br><br>

### 📄부호 있는 1의 보수 표현
부호 있는 1의 보수 표현방법은 양수의 경우 부호 있는 절대치 표현방법을 따르고 음수의 경우 부호를 제외한 그 수에 대한 1의 보수를 이용하여 표현합니다.
<br>

쉽게 말해 음수를 비트로 표현하는 방법 중 모든 비트를 반전시켜 뒤집는 방법입니다. 0을 1로 1을 0으로 반전시켜 음수로 표현하는 방법이 1의 보수 표현법입니다. 1의 보수 표현법에도 부호 비트를 사용합니다. 아래 표를 보면 +1인 0001<sub>2</sub>의 비트를 뒤집어 -1인 1110<sub>2</sub>으로 표현된 것을 볼 수 있습니다.
<br>

　　　　양수　　　　　　　　　음수
<br>

| 부호 | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> | 십진수 |   | 부호 | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> | 십진수 |
| :---: | :---: | :---: | :---: | :---: |   | :---: | :---: | :---: | :---: | :---: |
| 0 | 1 | 1 | 1 | +7 |   | 1 | 1 | 1 | 1 | -0 |
| 0 | 1 | 1 | 0 | +6 |   | 1 | 1 | 1 | 0 | -1 |
| 0 | 1 | 0 | 1 | +5 |   | 1 | 1 | 0 | 1 | -2 |
| 0 | 1 | 0 | 0 | +4 |   | 1 | 1 | 0 | 0 | -3 |
| 0 | 0 | 1 | 1 | +3 |   | 1 | 0 | 1 | 1 | -4 |
| 0 | 0 | 1 | 0 | +2 |   | 1 | 0 | 1 | 0 | -5 |
| 0 | 0 | 0 | 1 | +1 |   | 1 | 0 | 0 | 1 | -6 |
| 0 | 0 | 0 | 0 | +0 |   | 1 | 0 | 0 | 0 | -7 |

<br><br>

### 📄부호 있는 2의 보수 표현
부호 있는 2의 보수 표현방법은 양수의 경우 부호 있는 절대치 표현 방법을 따르고 음수의 경우 부호를 제외한 그 수에 대한 2의 보수를 이용하여 표현합니다.
<br>

위의 문제들을 해결하기 위해 2의 보수 표현법을 사용합니다. 2진수의 모든 자리의 숫자를 뒤집고 1을 더하면 2의 보수를 얻을 수 있습니다. 예를 들어 +1인 0001<sub>2</sub>을 반전시켜 1110<sub>2</sub>에 1을 추가하면 1111<sub>2</sub>이 -1이 되는 것입니다. 그리고 MSB에서 올림이 발생하면 버립니다.
<br>

　　　　양수　　　　　　　　　음수
<br>

| 부호 | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> | 십진수 |   | 부호 | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> | 십진수 |
| :---: | :---: | :---: | :---: | :---: |   | :---: | :---: | :---: | :---: | :---: |
| 0 | 1 | 1 | 1 | +7 |   | 1 | 1 | 1 | 1 | -1 |
| 0 | 1 | 1 | 0 | +6 |   | 1 | 1 | 1 | 0 | -2 |
| 0 | 1 | 0 | 1 | +5 |   | 1 | 1 | 0 | 1 | -3 |
| 0 | 1 | 0 | 0 | +4 |   | 1 | 1 | 0 | 0 | -4 |
| 0 | 0 | 1 | 1 | +3 |   | 1 | 0 | 1 | 1 | -5 |
| 0 | 0 | 1 | 0 | +2 |   | 1 | 0 | 1 | 0 | -6 |
| 0 | 0 | 0 | 1 | +1 |   | 1 | 0 | 0 | 1 | -7 |
| 0 | 0 | 0 | 0 | +0 |   | 1 | 0 | 0 | 0 | -8 |

<br>

2의 보수 표현법에서 0을 표현하는 방법은 한 가지 입니다. +0인 0000<sub>2</sub>을 뒤집으면 1111<sub>2</sub>이 되고 여기에 1을 더하면 MSB에 올림이 발생하는데 MSB에서 올림이 발생하면 그 값은 버린다고 했으므로 0000<sub>2</sub>과 같아집니다. 비트 덧셈 연산도 해봅시다. +1인 0001<sub>2</sub>과 -1인 1111<sub>2</sub>을 더하면 MSB에 올림 값 1이 생겨 10000<sub>2</sub>이 되는데 올림 값 1을 버리면 나머지 비트들은 0000<sub>2</sub>이 되어 결과는 10진수로 0인 0000<sub>2</sub>이 됩니다.

<br><br>
---
title: "[Algorithm]탐색1"
excerpt: "탐색1"

categories:
  - Algorithm
tags:
  - [알고리듬]

toc: true
toc_sticky: true

date: 2024-04-21
---

## 📚순차 탐색
### 📄탐색이란?

여러 개의 원소로 구성된 데이터에서 원하는 값을 갖는 원소를 찾는 것

데이터의 형태: 리스트, 트리, 그래프 등

관련 연산 -> 탐색 + 초기화, 삽입, 삭제

* 탐색 방법
	- 리스트 형태 -> 순차 탐색, 이진 탐색
	- 트리 형태 -> 이진 탐색 트리, 2-3-4 트리
	- 레드-블랙 트리, B-트리
	- 해시 테이블 -> 해시 함수, 충돌 행결 방법

<br>

### 📄순차 탐색

리스트 형태(배열, 연결리스트)로 주어진 원소들을 처음부터 하나씩 차례로 순차 비교하면서 원하는 값을 갖는 원소를 찾는 방법

```c
int SequentialSearch(int array[], int size, int target)
{
	int i = 0;

	// 배열의 크기 만큼 반복하고 target을 배열에서 찾을 때 까지 반복
	while (i < size && array[i] != target)
	{
		++i;
	}

	return i;
}
```

<br>

### 📄성능과 특징

* 탐색, 삭제 연산의 시간 복잡도: O(n)

탐색 성공 -> 1번 ~ n번 비교(평균 (n+1)/2번)

탐색 실패 -> 항상 n번 비교

삭제 -> 삭제할 원소의 순차 탐색 O(n) 후, 마지막 원소 이동 O(1)

* 삽입 연산의 시간 복잡도: O(1)

리스트의 마지막에 추가하는데 상수 시간만 필요

* 정렬되지 않고 크기가 작은 데이터에 적합: 모든 리스트 형태의 입력에 적용 가능 -> 비정렬 데이터 탐색에 적합하다.

<br><br>

## 📚이진 탐색
### 📄이진 탐색

정렬된 리스트 형태(배열)로 주어진 원소들을 절반씩 줄여 가면서 원하는 값을 가진 원소를 찾는 방법.

분할정복 방법이 적용된 알고리듬이다.

<br>

### 📄탐색 방법

배열의 가운데 원소 array[mid]와 탐색 키 key를 비교

mid = (시작 인덱스 left + 마지막 인덱스 right) / 2

1. array[mid] = key -> 탐색 성공(인덱스 mid 반환하고 종료)
2. key < array[mid] -> 이진탐색(원래 크기의 1/2인 왼쪽 부분배열) 순환 호출
3. key > array[mid] -> 이진탐색(원래 크기의 1/2인 오른쪽 부분배열) 순환 호출

```c
int BinarySearch(int array[], int key, int left, int right)
{
	if (left > right)
	{
		return -1;
	}

	int mid = (left + right) / 2;

	if (array[mid] == key)
	{
		return mid;
	}
	else if (array[mid] > key)
	{
		BinarySearch(array, key, left, mid - 1);
	}
	else
	{
		BinarySearch(array, key, mid + 1, right);
	}
}
```

<br>

### 📄성능과 특징

이진 탐색은 주어진 배열이 정렬되어 있지 않으면 탐색을 할 수 없으므로 정렬을 먼저 수행해야 한다.

이진 탐색은 원소의 직접적인 접근(배열의 중간값에 접근)이 필요하기 때문에 연결 리스트 구조에서는 이진 탐색이 불가능하다.

* 성능
	- 탐색: O(logn)
	- 초기화 연산: O(nlogn) -> 처음에 배열을 정렬 시켜줘야 하기 때문
	- 삽입/삭제 연산: O(n) -> 삽입과 삭제할 위치를 찾았으면 나머지 원소들을 하나씩 옮겨줘야 하기 때문

이진 탐색은 삽입과 삭제가 빈번한 경우에 부적합하다. 연산 후 리스트의 정렬 상태를 유지하기 위해 O(n)의 데이터 이동이 필요하기 때문이다.

<br><br>